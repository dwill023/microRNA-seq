---
title: "MicroRNA count normalization and differential expression"
output: html_notebook
---

MicroRNA data analysis Starting with raw read counts generated by subread/1.6.2 featureCounts function.


## Creating a DGEList object


Read in the counts file and make the row.names the gene column. Prepare the DGEList by first specifying the grouping of the samples. 

```{r echo=TRUE}
library(edgeR)
library(tidyverse)

data <- read.delim("miRTox_counts.txt") 

d <- data[,2:13]
rownames(d) <- data$X1
 
group <- c(rep("mir_1",3), rep("mir_2",3), rep("mir_3",3),  rep("Control",3))
d <- DGEList(counts = d, group=group)
d
```


## Filtering the data
Remove genes in the counts that have low expression. We will remove all genes that have less than 1 CPM in at least two samples. 

```{r echo=TRUE}
head(cpm(d))

keep <- rowSums(cpm(d)>1) >= 2
d.filt <- d[keep,]
dim(d.filt)

```

After filtering, it is a good idea to reset the library sizes:
```{r}
d.filt$samples$lib.size <- colSums(d.filt$counts)
d.filt$samples
```


## Data normalization

The `calcNormFactors()` function normalizes for RNA composition by finding a set of scaling factor for the library sizes that minimize the log-fold changes between the samples for most genes. 

This uses the trimmed mean of M-values (TMM) for comupting these scale factors. 

The product of the original library size and the scaling fator = the effective library size. This replaces the original library size in all downstream analyses. 
```{r echo=TRUE}
d.filt <- calcNormFactors(d.filt)
d.filt
```

Generate a boxplot to compare between unnormalized and normalized counts. 
```{r}
# Get log2 counts per million for the unnormalized counts
logcounts <- cpm(d.filt, log=TRUE, normalized.lib.sizes=FALSE)
# Check distributions of samples using boxplots, a blue horizontal line that corresponds to the median logCPM
drawLines <- function() abline(h=median(logcounts),col="blue")
boxplot(logcounts, ylab="Log2 counts per million",las=2, main= "Boxplots of logCPMs unnormalized"); drawLines()

# perform the same for normalized counts
logcounts2 <- cpm(d.filt, log=TRUE, normalized.lib.sizes=TRUE)
drawLines <- function() abline(h=median(logcounts2),col="blue")
boxplot(logcounts2, ylab="Log2 counts per million",las=2, main= "Boxplots of logCPMs normalized"); drawLines()


# export the logcounts into a file
write.csv(logcounts2, "logCPM_mirtox.csv")
```


## Multidimentional scaling
This plot shows the relations between the samples. Similar to a PCA plot but with different scaling.
```{r fig.height=6, fig.width=8, message=FALSE, warning=FALSE}
plotMDS(d.filt, method="bcv", col=as.numeric(d.filt$samples$group)) + legend("bottomleft", as.character(unique(d.filt$samples$group)), col=1:3, pch=20)
```

## GLM estimates of dispersion

Estimating a gernaralized linear model (glm) fit. There are three steps to do this in edgeR:

- Fit common dispersion: this is a measure of the degree of inter-library variation for that tag. This will provide an idea of the overall variablility across the genome.
- Fit a trended model: stimate based on the mean-variance trend across the dataset, such that genes similar abundances have similar variance estimates (trended dispersion).
- Fit the tagwise dispersion: a genewise dispersion

```{r echo=TRUE}
# first we need to specify a design matrix which describes the setup of the experiment.
design.mat <- model.matrix(~ 0 + d.filt$samples$group)
colnames(design.mat) <- levels(d$samples$group)


d2 <- estimateGLMCommonDisp(d.filt, design.mat)
d2 <- estimateGLMTrendedDisp(d2,design.mat)
d2 <- estimateGLMTagwiseDisp(d2,design.mat)
```

## Differential Expression

Once the dispersions are estimated, we can proceed with testing procedures for determining differential expression. 
```{r}
design.mat
```

```{r}
fit <- glmFit(d2, design.mat)

# compare group 1 to group 2
mir_1 <- glmLRT(fit, contrast=c(1,-1,0,0)) # mir_1 vs Control
mir_2 <- glmLRT(fit, contrast=c(0,-1,1,0)) # mir_2 vs Control
mir_3 <- glmLRT(fit, contrast=c(0,-1,0,1)) # mir_3 vs Control
topTags(mir_1, n=50)
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align=center}
de1 <- decideTestsDGE(mir_1, adjust.method="BH", p.value = 0.05)

de1tags <- rownames(d2)[as.logical(de1)]

plotSmear(mir_1, de.tags=de1tags) + abline(h = c(-1, 1), col = "blue")
```

export the DEG table.
```{r echo=TRUE}
write.csv(as.data.frame(topTags(mir_1, n= length(row.names(d2)))), "mir1_DEGS_edgeR.csv" )
```

```{r}
sessionInfo()
```

